package internal

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// InjectPattern matches //:inject:MethodName
const InjectPattern = `^\s*//\s*:inject:(\w+)\s*$`

// Markers for injected code blocks (follows Go convention for generated code)
const injectBlockStart = "// Code generated by goahead. DO NOT EDIT."
const injectBlockEnd = "// End of goahead generated code."

// InjectionResult contains the extracted function and its dependencies
type InjectionResult struct {
	FunctionCode  string
	FunctionDecls map[string]string // Individual function declarations keyed by name
	DepDecls      map[string]string // Individual dependency declarations (const/var/type) keyed by name
	Imports       []string
	Constants     string
	Variables     string
	Types         string
}

// Injector handles function injection from helper files
type Injector struct {
	ctx *ProcessorContext
}

// NewInjector creates a new Injector
func NewInjector(ctx *ProcessorContext) *Injector {
	return &Injector{ctx: ctx}
}

// ProcessFileInjections handles all //:inject: directives in a file.
// Inject markers must appear above an interface declaration.
// The method name must exist in that interface.
func (inj *Injector) ProcessFileInjections(filePath string, verbose bool) error {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read file: %v", err)
	}

	sourceDir := filepath.Dir(filePath)
	absSourceDir, _ := filepath.Abs(sourceDir)

	injectRe := regexp.MustCompile(InjectPattern)
	lines := strings.Split(string(content), "\n")

	// Remove any previously injected blocks to avoid duplication on subsequent runs
	lines, err = inj.removeInjectedBlocks(lines)
	if err != nil {
		return err
	}

	// First pass: find all inject markers and their associated interfaces
	type injectRequest struct {
		lineIdx      int
		methodName   string
		interfaceIdx int
		ifaceName    string
	}

	var requests []injectRequest
	var pendingMarkers []struct {
		lineIdx    int
		methodName string
	}

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Check for inject marker
		if match := injectRe.FindStringSubmatch(line); match != nil {
			pendingMarkers = append(pendingMarkers, struct {
				lineIdx    int
				methodName string
			}{lineIdx: i, methodName: match[1]})
			continue
		}

		// Check for interface declaration (after markers)
		if len(pendingMarkers) > 0 && strings.HasPrefix(trimmed, "type ") && strings.Contains(trimmed, "interface") {
			// Extract interface name
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				ifaceName := parts[1]

				// Parse interface methods
				interfaceMethods := inj.parseInterfaceMethods(lines, i)

				// Validate each pending marker
				for _, pm := range pendingMarkers {
					if _, exists := interfaceMethods[pm.methodName]; !exists {
						return fmt.Errorf("method '%s' not found in interface '%s' at %s:%d",
							pm.methodName, ifaceName, filePath, pm.lineIdx+1)
					}
					requests = append(requests, injectRequest{
						lineIdx:      pm.lineIdx,
						methodName:   pm.methodName,
						interfaceIdx: i,
						ifaceName:    ifaceName,
					})
				}
			}
			pendingMarkers = nil
		}

		// Non-empty, non-comment line after markers without interface = error
		if len(pendingMarkers) > 0 && trimmed != "" && !strings.HasPrefix(trimmed, "//") {
			return fmt.Errorf("//:inject markers at %s:%d must be followed by an interface declaration",
				filePath, pendingMarkers[0].lineIdx+1)
		}
	}

	// Check for dangling markers at end of file
	if len(pendingMarkers) > 0 {
		return fmt.Errorf("//:inject markers at %s:%d must be followed by an interface declaration",
			filePath, pendingMarkers[0].lineIdx+1)
	}

	if len(requests) == 0 {
		return nil
	}

	// Extract functions and build injection content, deduplicating shared dependencies
	var importsToAdd []string
	var depsToAdd []string
	var funcsToAdd []string
	seenFuncs := make(map[string]bool)
	seenDeps := make(map[string]bool)

	for _, req := range requests {
		result, err := inj.ExtractFunction(req.methodName, absSourceDir)
		if err != nil {
			return fmt.Errorf("cannot inject method '%s' for interface '%s': %v",
				req.methodName, req.ifaceName, err)
		}

		importsToAdd = append(importsToAdd, result.Imports...)

		// Deduplicate dependency declarations (const/var/type) across requests
		var depNames []string
		for name := range result.DepDecls {
			depNames = append(depNames, name)
		}
		sort.Strings(depNames)
		for _, name := range depNames {
			if !seenDeps[name] {
				seenDeps[name] = true
				depsToAdd = append(depsToAdd, result.DepDecls[name])
			}
		}

		// Deduplicate function declarations across requests
		// Add the target function first, then its dependencies in sorted order
		if !seenFuncs[req.methodName] {
			seenFuncs[req.methodName] = true
			if code, ok := result.FunctionDecls[req.methodName]; ok {
				funcsToAdd = append(funcsToAdd, code)
			}
		}
		var depFuncNames []string
		for name := range result.FunctionDecls {
			if name == req.methodName {
				continue
			}
			depFuncNames = append(depFuncNames, name)
		}
		sort.Strings(depFuncNames)
		for _, name := range depFuncNames {
			if !seenFuncs[name] {
				seenFuncs[name] = true
				funcsToAdd = append(funcsToAdd, result.FunctionDecls[name])
			}
		}

		if verbose {
			fmt.Fprintf(os.Stderr, "[goahead] Injected method '%s' for interface '%s' in %s\n",
				req.methodName, req.ifaceName, filePath)
		}
	}

	// Build new file content
	// 1. Keep inject markers (they stay!)
	// 2. Add imports
	// 3. Add dependencies after imports
	// 4. Add functions at end of file

	// Insert imports only (dependencies will be appended in the injected block)
	finalContent := inj.insertImportsAndDeps(lines, importsToAdd, nil)

	// Append injected block at end (deps + functions)
	finalContent = strings.TrimRight(finalContent, "\n") + "\n"
	finalContent += "\n" + injectBlockStart + "\n"

	for _, dep := range depsToAdd {
		trimmed := strings.TrimSpace(dep)
		if trimmed != "" {
			finalContent += trimmed + "\n"
		}
	}

	for _, fn := range funcsToAdd {
		finalContent += "\n" + fn + "\n"
	}

	finalContent += injectBlockEnd + "\n"

	return os.WriteFile(filePath, []byte(finalContent), 0o644)
}

// parseInterfaceMethods extracts method names from an interface declaration
func (inj *Injector) parseInterfaceMethods(lines []string, startIdx int) map[string]bool {
	methods := make(map[string]bool)
	braceCount := 0
	started := false

	for i := startIdx; i < len(lines); i++ {
		line := lines[i]
		for _, c := range line {
			if c == '{' {
				braceCount++
				started = true
			}
			if c == '}' {
				braceCount--
				if started && braceCount == 0 {
					return methods
				}
			}
		}

		// Extract method name (first word followed by '(')
		trimmed := strings.TrimSpace(line)
		if started && !strings.HasPrefix(trimmed, "//") && trimmed != "{" && trimmed != "}" {
			if idx := strings.Index(trimmed, "("); idx > 0 {
				methodName := strings.TrimSpace(trimmed[:idx])
				if methodName != "" && !strings.Contains(methodName, " ") {
					methods[methodName] = true
				}
			}
		}
	}

	return methods
}

// removeExistingFunctions removes function declarations that match the given names
// removeInjectedBlocks removes previously injected blocks to avoid duplication
func (inj *Injector) removeInjectedBlocks(lines []string) ([]string, error) {
	var result []string
	i := 0

	for i < len(lines) {
		trimmed := strings.TrimSpace(lines[i])
		if trimmed == injectBlockStart {
			// Skip until end marker
			foundEnd := false
			i++
			for i < len(lines) {
				if strings.TrimSpace(lines[i]) == injectBlockEnd {
					foundEnd = true
					i++
					break
				}
				i++
			}
			if !foundEnd {
				return nil, fmt.Errorf("unclosed injected block in file")
			}
			// Skip any trailing empty lines after the block
			for i < len(lines) && strings.TrimSpace(lines[i]) == "" {
				i++
			}
			continue
		}

		result = append(result, lines[i])
		i++
	}

	return result, nil
}

// ExtractFunction extracts a function and its dependencies from helper files
func (inj *Injector) ExtractFunction(funcName, sourceDir string) (*InjectionResult, error) {
	// Find the function using hierarchical resolution
	userFunc, helperPath := inj.ctx.ResolveFunction(funcName, sourceDir)
	if userFunc == nil {
		return nil, fmt.Errorf("implementation '%s' not found in any helper file", funcName)
	}

	// Parse the helper file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, helperPath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse helper file %s: %v", helperPath, err)
	}

	result := &InjectionResult{}

	// Build map of helper functions
	funcDecls := make(map[string]*ast.FuncDecl)
	for _, decl := range node.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			funcDecls[fn.Name.Name] = fn
		}
	}

	// Ensure the target exists
	funcDecl, ok := funcDecls[funcName]
	if !ok {
		return nil, fmt.Errorf("function '%s' not found in %s", funcName, helperPath)
	}

	// Collect dependent helper functions recursively
	included := make(map[string]*ast.FuncDecl)
	queue := []string{funcName}

	for len(queue) > 0 {
		name := queue[0]
		queue = queue[1:]

		if _, already := included[name]; already {
			continue
		}
		fn := funcDecls[name]
		if fn == nil {
			continue
		}
		included[name] = fn

		used := inj.collectUsedIdentifiers(fn)
		for ident := range used {
			if ident == name {
				continue
			}
			if _, exists := funcDecls[ident]; exists {
				queue = append(queue, ident)
			}
		}
	}

	// Collect identifiers used by all included functions
	usedIdents := make(map[string]bool)
	for _, fn := range included {
		for ident := range inj.collectUsedIdentifiers(fn) {
			usedIdents[ident] = true
		}
	}

	// Extract only the imports that are actually used
	for _, imp := range node.Imports {
		// Get the package name (either alias or last part of path)
		var pkgName string
		if imp.Name != nil {
			pkgName = imp.Name.Name
		} else {
			// Extract package name from path (e.g., "encoding/hex" -> "hex")
			path := strings.Trim(imp.Path.Value, `"`)
			parts := strings.Split(path, "/")
			pkgName = parts[len(parts)-1]
		}

		// Check if this package is used
		if usedIdents[pkgName] {
			var importSpec string
			if imp.Name != nil {
				importSpec = imp.Name.Name + " " + imp.Path.Value
			} else {
				importSpec = imp.Path.Value
			}
			result.Imports = append(result.Imports, importSpec)
		}
	}

	// Extract dependencies (const, var, type) that are used
	result.DepDecls = inj.extractDependencyDecls(node, fset, usedIdents)

	// Build individual function declarations for deduplication across injection requests
	result.FunctionDecls = make(map[string]string)
	for name, fn := range included {
		var buf strings.Builder
		if err := printer.Fprint(&buf, fset, fn); err != nil {
			return nil, fmt.Errorf("failed to print function '%s': %v", name, err)
		}
		result.FunctionDecls[name] = buf.String()
	}

	// Build concatenated function code (target first, then dependencies sorted)
	var funcBuf strings.Builder
	if err := printer.Fprint(&funcBuf, fset, funcDecl); err != nil {
		return nil, fmt.Errorf("failed to print function: %v", err)
	}

	var otherNames []string
	for name := range included {
		if name == funcName {
			continue
		}
		otherNames = append(otherNames, name)
	}
	sort.Strings(otherNames)

	for _, name := range otherNames {
		funcBuf.WriteString("\n\n")
		if err := printer.Fprint(&funcBuf, fset, included[name]); err != nil {
			return nil, fmt.Errorf("failed to print dependent function: %v", err)
		}
	}

	result.FunctionCode = funcBuf.String()
	return result, nil
}

// collectUsedIdentifiers finds all identifiers used in a function
func (inj *Injector) collectUsedIdentifiers(fn *ast.FuncDecl) map[string]bool {
	used := make(map[string]bool)

	if fn.Recv != nil {
		ast.Inspect(fn.Recv, func(n ast.Node) bool {
			if ident, ok := n.(*ast.Ident); ok {
				used[ident.Name] = true
			}
			return true
		})
	}
	if fn.Type != nil {
		ast.Inspect(fn.Type, func(n ast.Node) bool {
			if ident, ok := n.(*ast.Ident); ok {
				used[ident.Name] = true
			}
			return true
		})
	}
	if fn.Body != nil {
		ast.Inspect(fn.Body, func(n ast.Node) bool {
			if ident, ok := n.(*ast.Ident); ok {
				used[ident.Name] = true
			}
			return true
		})
	}

	return used
}

// extractDependencies extracts const/var/type declarations used by the function
func (inj *Injector) extractDependencies(file *ast.File, fset *token.FileSet, usedIdents map[string]bool) (constants, variables, types string) {
	depDecls := inj.extractDependencyDecls(file, fset, usedIdents)
	var constBuf, varBuf, typeBuf strings.Builder
	for name, code := range depDecls {
		// Classify by prefix to maintain backward compatibility
		if strings.HasPrefix(code, "const ") {
			constBuf.WriteString(code)
			constBuf.WriteString("\n")
		} else if strings.HasPrefix(code, "var ") {
			varBuf.WriteString(code)
			varBuf.WriteString("\n")
		} else if strings.HasPrefix(code, "type ") {
			typeBuf.WriteString(code)
			typeBuf.WriteString("\n")
		}
		_ = name // used as key for deduplication
	}
	return constBuf.String(), varBuf.String(), typeBuf.String()
}

// extractDependencyDecls extracts const/var/type declarations as a map keyed by name for deduplication
func (inj *Injector) extractDependencyDecls(file *ast.File, fset *token.FileSet, usedIdents map[string]bool) map[string]string {
	result := make(map[string]string)

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		switch genDecl.Tok {
		case token.CONST:
			for _, spec := range genDecl.Specs {
				vs := spec.(*ast.ValueSpec)
				for _, name := range vs.Names {
					if usedIdents[name.Name] {
						var buf strings.Builder
						printer.Fprint(&buf, fset, &ast.GenDecl{
							Tok:   token.CONST,
							Specs: []ast.Spec{vs},
						})
						result[name.Name] = buf.String()
						break
					}
				}
			}
		case token.VAR:
			for _, spec := range genDecl.Specs {
				vs := spec.(*ast.ValueSpec)
				for _, name := range vs.Names {
					if usedIdents[name.Name] {
						var buf strings.Builder
						printer.Fprint(&buf, fset, &ast.GenDecl{
							Tok:   token.VAR,
							Specs: []ast.Spec{vs},
						})
						result[name.Name] = buf.String()
						break
					}
				}
			}
		case token.TYPE:
			for _, spec := range genDecl.Specs {
				ts := spec.(*ast.TypeSpec)
				if usedIdents[ts.Name.Name] {
					var buf strings.Builder
					printer.Fprint(&buf, fset, &ast.GenDecl{
						Tok:   token.TYPE,
						Specs: []ast.Spec{ts},
					})
					result[ts.Name.Name] = buf.String()
				}
			}
		}
	}

	return result
}

// insertImportsAndDeps adds imports and dependencies to the file content
func (inj *Injector) insertImportsAndDeps(lines []string, imports []string, deps []string) string {
	if len(imports) == 0 && len(deps) == 0 {
		return strings.Join(lines, "\n")
	}

	importSet := make(map[string]bool)
	for _, imp := range imports {
		importSet[imp] = true
	}

	packageLineIdx := -1
	importStart := -1
	importEnd := -1
	importSingle := -1
	inImport := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "package ") && packageLineIdx == -1 {
			packageLineIdx = i
		}
		if strings.HasPrefix(trimmed, "import (") {
			importStart = i
			inImport = true
		}
		if inImport && trimmed == ")" {
			importEnd = i
			inImport = false
		}
		if strings.HasPrefix(trimmed, "import ") && !strings.HasSuffix(trimmed, "(") {
			if importStart == -1 {
				importSingle = i
			}
		}
	}

	var result []string
	insertedDeps := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Convert single-line import into block if needed
		if i == importSingle && len(importSet) > 0 {
			spec := strings.TrimSpace(strings.TrimPrefix(trimmed, "import"))
			result = append(result, "import (")
			if spec != "" {
				result = append(result, "\t"+spec)
			}
			for imp := range importSet {
				if spec == imp {
					continue
				}
				result = append(result, "\t"+imp)
			}
			result = append(result, ")")
			continue
		}

		result = append(result, line)

		// Insert imports after package if none exist
		if i == packageLineIdx && importStart == -1 && importSingle == -1 && len(importSet) > 0 {
			result = append(result, "")
			result = append(result, "import (")
			for imp := range importSet {
				result = append(result, "\t"+imp)
			}
			result = append(result, ")")
		}

		// Extend import block before closing )
		if i == importEnd && len(importSet) > 0 {
			result = result[:len(result)-1]
			for imp := range importSet {
				found := false
				for j := importStart; j <= importEnd; j++ {
					if strings.Contains(lines[j], imp) {
						found = true
						break
					}
				}
				if !found {
					result = append(result, "\t"+imp)
				}
			}
			result = append(result, ")")
		}

		// Insert dependencies after imports
		if !insertedDeps && len(deps) > 0 {
			if i == importEnd || (importStart == -1 && importSingle == -1 && i == packageLineIdx) || i == importSingle {
				result = append(result, "")
				for _, dep := range deps {
					result = append(result, strings.TrimSpace(dep))
				}
				insertedDeps = true
			}
		}
	}

	return strings.Join(result, "\n")
}
